# 环境变量运行时读取修复说明

## 📋 问题描述

之前的代码存在一个**严重的生产环境问题**：

在编译时读取环境变量会导致本地开发环境的配置被**硬编码**到`dist`目录中。当代码部署到生产服务器时，仍然会使用本地的值而不是服务器的环境变量。

```typescript
// ❌ 错误做法（在编译时执行）
const JWT_SECRET = process.env.JWT_SECRET;  // 读取本地dev值，硬编码到dist
```

## ✅ 解决方案

### 核心思想
将所有环境变量从**编译时读取**改为**运行时读取**，这样编译后的代码仍然包含 `process.env.XXX` 的引用，在任何环境运行时都会读取当前环境的变量值。

```typescript
// ✅ 正确做法（在运行时执行）
const JWT_SECRET = config.jwt.secret;  // 运行时从config对象读取
// config对象内部在应用启动时读取process.env
```

## 🔧 修改内容

### 1. 创建配置模块 (`src/config/index.ts`)

新建统一的配置管理模块，所有环境变量在应用启动时一次性读取：

```typescript
export const config = {
  app: {
    port: parseInt(process.env.PORT || '3000'),
    nodeEnv: process.env.NODE_ENV || 'development',
  },
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  },
  database: {
    url: process.env.DATABASE_URL,
    // ... 其他数据库配置
  },
  // ... 其他配置分类
};

export function validateConfig(): void {
  // 验证必要的环境变量
}
```

**优势：**
- ✅ 集中管理所有环境变量
- ✅ 只需改一个地方，所有代码自动生效
- ✅ 运行时读取，确保任何环境都能获取正确的配置
- ✅ 支持默认值，提高灵活性

### 2. 修改 `src/shared/middleware/auth.ts`

改为在函数体内读取`config`对象：

```typescript
// ✅ 运行时读取（在函数体内）
export const generateToken = (payload: Omit<JWTPayload, 'iat' | 'exp' | 'jti'>): string => {
  const JWT_SECRET = config.jwt.secret;  // ← 函数被调用时读取
  
  if (!JWT_SECRET) {
    throw new Error('JWT_SECRET未设置');
  }
  
  // ... 生成token的逻辑
};
```

### 3. 更新 `src/index.ts`

在应用启动时验证并记录配置信息：

```typescript
// 导入配置模块
import { config, validateConfig, getConfigInfo } from './config';

// 应用启动时验证配置
validateConfig();
logger.info('🔧 应用配置信息:', getConfigInfo());
```

## 🚀 部署流程

### 方式1：使用PowerShell脚本（Windows用户推荐）

```powershell
# 自动完成：本地编译 → 验证 → 上传 → 远程重启
.\scripts\deploy-config-fix.ps1
```

**脚本功能：**
1. ✅ 本地编译（npm run build）
2. ✅ 验证编译结果（检查环境变量是否被硬编码）
3. ✅ 备份远程的旧dist
4. ✅ 上传新编译的dist到远程
5. ✅ 重启远程应用（PM2/systemd）
6. ✅ 验证部署成功（健康检查）

### 方式2：使用Bash脚本（Linux/Mac或远程服务器）

```bash
bash scripts/deploy-and-verify.sh production 162.14.114.224 root /www/wwwroot/zd-api.wenbita.cn
```

## 📦 编译验证

部署脚本会自动验证编译结果，但你也可以手动验证：

```bash
# 编译
npm run build

# 检查编译后的文件是否包含process.env引用（而非硬编码值）
cat dist/config/index.js | grep -i "process.env"
# 输出示例：
# secret: process.env.JWT_SECRET,
# url: process.env.DATABASE_URL,
```

✅ 如果看到 `process.env.XXX`，说明验证成功（环境变量没有被硬编码）

## 🔐 生产环境配置

### 必需的环境变量

在远程服务器上设置以下环境变量：

```bash
# JWT配置
export JWT_SECRET="your-production-jwt-secret-key"
export JWT_EXPIRES_IN="7d"
export JWT_REFRESH_EXPIRES_IN="30d"

# 数据库配置
export DATABASE_URL="mysql://user:password@host:3306/dbname"
export DB_HOST="cd-cynosdbmysql-grp-5q7r23ge.sql.tencentcdb.com"
export DB_PORT="22947"
export DB_USER="zhongdao_mall"
export DB_PASSWORD="your-db-password"
export DB_NAME="zhongdao-mall"

# 应用配置
export NODE_ENV="production"
export PORT="3000"

# CORS配置
export CORS_ORIGIN="https://zd-h5.wenbita.cn,https://zd-admin.wenbita.cn"

# 微信配置（如果需要）
export WECHAT_APP_ID="your-appid"
export WECHAT_APP_SECRET="your-secret"
export WECHAT_MCH_ID="your-mch-id"
export WECHAT_KEY="your-key"
export WECHAT_API_V3_KEY="your-v3-key"
```

### PM2启动

如果使用PM2，确保 `ecosystem.config.js` 中配置了这些环境变量：

```javascript
module.exports = {
  apps: [{
    name: 'api',
    script: './dist/index.js',
    env: {
      NODE_ENV: 'production',
      JWT_SECRET: process.env.JWT_SECRET,
      DATABASE_URL: process.env.DATABASE_URL,
      // ... 其他环境变量
    }
  }]
};
```

### 使用systemd管理

创建服务文件 `/etc/systemd/system/node-zd-api.service`：

```ini
[Unit]
Description=ZhongDao Mall API Service
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/www/wwwroot/zd-api.wenbita.cn
ExecStart=/usr/local/bin/node dist/index.js

# 环境变量设置
Environment="NODE_ENV=production"
Environment="JWT_SECRET=your-secret"
Environment="DATABASE_URL=your-db-url"
# ... 其他环境变量

Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

启动服务：
```bash
systemctl daemon-reload
systemctl start node-zd-api
systemctl enable node-zd-api  # 开机自启
```

## ✅ 验证部署

### 1. 检查应用是否启动

```bash
# PM2
pm2 list
pm2 logs api

# systemd
systemctl status node-zd-api
journalctl -u node-zd-api -f

# 手动
ps aux | grep "node dist/index.js"
```

### 2. 测试API端点

```bash
# 健康检查
curl https://zd-api.wenbita.cn/health

# 期望响应
{
  "code": "SUCCESS",
  "status": "ok",
  "timestamp": "2024-XX-XX",
  "environment": "production",
  "uptime": 123.45
}
```

### 3. 检查配置是否正确读取

```bash
# 查看应用日志
pm2 logs api

# 应该看到类似的输出
# 🔧 应用配置信息: {
#   app: { port: 3000, nodeEnv: 'production', ... },
#   jwt: { secret: '***[已设置]', ... },
#   database: { url: '***[已设置]', ... }
# }
```

## 🔄 快速参考

### 本地开发

```bash
# 1. 设置本地环境变量
cp .env.development.local .env.development
# 编辑.env.development，设置本地值

# 2. 启动开发服务器
npm run dev

# 3. 编译验证
npm run build
```

### 生产部署

```bash
# 1. 在远程服务器设置环境变量
ssh root@162.14.114.224
vim /etc/profile.d/node-env.sh
# 添加: export JWT_SECRET="..."
# 添加: export DATABASE_URL="..."

# 2. 部署（从本地运行）
# Windows:
.\scripts\deploy-config-fix.ps1

# Linux/Mac:
bash scripts/deploy-and-verify.sh

# 3. 验证
ssh root@162.14.114.224
curl http://localhost:3000/health
```

## ⚠️ 常见问题

### Q1: 为什么本地编译的代码在服务器上不工作？

**原因：** 可能代码仍然存在编译时读取环境变量的地方。

**检查方法：**
```bash
grep -r "process\.env\.\w\+ *=" src --include="*.ts" | grep -v "// " | grep -v " *=>"
```

这会找出所有在模块顶部直接赋值的环境变量。应该改为在函数体内读取。

### Q2: 部署后应用启动失败

**检查清单：**
1. ✅ 远程服务器是否设置了环境变量？
   ```bash
   ssh root@162.14.114.224 "env | grep JWT_SECRET"
   ```

2. ✅ 应用日志中的错误信息？
   ```bash
   pm2 logs api --err
   ```

3. ✅ 数据库连接是否正常？
   ```bash
   curl https://zd-api.wenbita.cn/health/database
   ```

### Q3: 如何恢复到之前的版本？

```bash
# 查看可用的备份
ssh root@162.14.114.224 "ls -la /www/wwwroot/zd-api.wenbita.cn/dist_backup_*"

# 恢复备份
ssh root@162.14.114.224 "
  cd /www/wwwroot/zd-api.wenbita.cn
  rm -rf dist
  cp -r dist_backup_20240115_143000 dist
  pm2 restart api
"
```

## 📚 相关文件

- `src/config/index.ts` - 配置模块（115行）
- `src/shared/middleware/auth.ts` - 已修改，改为运行时读取
- `src/index.ts` - 已修改，添加配置验证
- `scripts/deploy-config-fix.ps1` - PowerShell部署脚本
- `scripts/deploy-and-verify.sh` - Bash部署脚本

## 🎯 总结

这个修复确保了：
- ✅ 本地编译的代码可以在任何环境运行（开发/测试/生产）
- ✅ 环境变量在运行时正确读取，不会被硬编码
- ✅ 自动化部署流程，减少手动操作和错误
- ✅ 完整的部署验证和回滚能力
