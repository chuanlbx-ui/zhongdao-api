# ä¸­é“å•†åŸç³»ç»Ÿ - æµ‹è¯•ç­–ç•¥ä¸è´¨é‡ä¿è¯

**æ–‡æ¡£ç›®çš„**ï¼šå®šä¹‰å®Œæ•´çš„æµ‹è¯•ç­–ç•¥ã€è´¨é‡æ ‡å‡†å’Œè´¨é‡æ§åˆ¶æµç¨‹
**é€‚ç”¨èŒƒå›´**ï¼šæ‰€æœ‰æµ‹è¯•æ´»åŠ¨ã€ä»£ç å®¡æŸ¥å’Œè´¨é‡ä¿è¯å·¥ä½œ
**æœ€åæ›´æ–°**ï¼š2025å¹´11æœˆ18æ—¥
**ç‰ˆæœ¬**ï¼š1.0

---

## ğŸ¯ æµ‹è¯•ç­–ç•¥æ¦‚è§ˆ

### æµ‹è¯•é‡‘å­—å¡”

```
                    /\
                   /  \
                  / E2E \
                 / æµ‹è¯•  \
                /      \
              /  é›†æˆ   \
             /          \
          /    å•å…ƒ     \
         /              \
    å¼€å‘é€Ÿåº¦    æµ‹è¯•éš¾åº¦    æµ‹è¯•ç¨³å®šæ€§
```

### æµ‹è¯•å±‚çº§åˆ†å·¥

| æµ‹è¯•ç±»å‹ | è´Ÿè´£äºº | å®æ–½æ—¶é—´ | é¢‘ç‡ | è¦†ç›–èŒƒå›´ |
|---------|--------|----------|--------|----------|
| **å•å…ƒæµ‹è¯•** | å¼€å‘AI | å¼€å‘è¿‡ç¨‹ä¸­ | æ¯æ¬¡æäº¤ | å‡½æ•°çº§åˆ« |
| **é›†æˆæµ‹è¯•** | å¼€å‘AI | åŠŸèƒ½å®Œæˆå | æ¯æ—¥ | æ¨¡å—çº§åˆ« |
| **E2Eæµ‹è¯•** | æµ‹è¯•AI | ç‰ˆæœ¬å‘å¸ƒå‰ | æ¯å‘¨ | ç«¯åˆ°ç«¯æµç¨‹ |
| **æ€§èƒ½æµ‹è¯•** | ä¸“é—¨AI | ç‰ˆæœ¬å‘å¸ƒå‰ | æ¯æœˆ | ç³»ç»Ÿæ€§èƒ½ |
| **å®‰å…¨æµ‹è¯•** | ä¸“é—¨AI | ç‰ˆæœ¬å‘å¸ƒå‰ | æ¯æœˆ | å®‰å…¨æ¼æ´ |

---

## ğŸ§ª å•å…ƒæµ‹è¯•ç­–ç•¥

### æµ‹è¯•è¦†ç›–ç‡è¦æ±‚

```typescript
interface CoverageRequirements {
  statements: number;    // è¯­å¥è¦†ç›–ç‡ï¼šâ‰¥80%
  branches: number;      // åˆ†æ”¯è¦†ç›–ç‡ï¼šâ‰¥75%
  functions: number;     // å‡½æ•°è¦†ç›–ç‡ï¼šâ‰¥85%
  lines: number;         // è¡Œè¦†ç›–ç‡ï¼šâ‰¥80%
  criticalLogic: number; // æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼š100%
}
```

### å•å…ƒæµ‹è¯•è§„èŒƒ

#### ä¸šåŠ¡é€»è¾‘æµ‹è¯•æ¨¡æ¿

```typescript
// tests/unit/services/user-level-upgrade.test.ts
import { UserLevelUpgradeService } from '../../../src/services/user-level-upgrade';
import { UserService } from '../../../src/services/user';

describe('UserLevelUpgradeService', () => {
  let upgradeService: UserLevelUpgradeService;
  let userService: jest.Mocked<UserService>;

  beforeEach(() => {
    userService = new UserService() as jest.Mocked<UserService>;
    upgradeService = new UserLevelUpgradeService(userService);
  });

  describe('checkUpgradeConditions', () => {
    describe('ç”¨æˆ·ç­‰çº§å‡çº§æ¡ä»¶éªŒè¯', () => {
      it('åº”è¯¥æ­£ç¡®è¯†åˆ«ä¸€æ˜Ÿåº—é•¿å‡çº§æ¡ä»¶', async () => {
        // Arrange
        const userId = 123;
        const mockUser = {
          id: userId,
          level: 'normal',
          totalSales: 12000, // 20ç“¶Ã—599=11980
          teamStructure: { levelDistribution: { star_1: 2 } }
        };
        userService.getUserById.mockResolvedValue(mockUser);

        // Act
        const result = await upgradeService.checkUpgradeConditions(userId);

        // Assert
        expect(result.canUpgrade).toBe(true);
        expect(result.targetLevel).toBe('star_2');
      });

      it('åº”è¯¥æ‹’ç»é”€é‡ä¸è¶³çš„å‡çº§è¯·æ±‚', async () => {
        // Arrange
        const userId = 123;
        const mockUser = {
          id: userId,
          level: 'normal',
          totalSales: 5000, // ä¸è¶³20ç“¶
          teamStructure: { levelDistribution: { star_1: 2 } }
        };
        userService.getUserById.mockResolvedValue(mockUser);

        // Act
        const result = await upgradeService.checkUpgradeConditions(userId);

        // Assert
        expect(result.canUpgrade).toBe(false);
        expect(result.requirements.bottleCount).toBe(20);
        expect(result.currentProgress.bottleCount).toBe(8);
      });

      it('åº”è¯¥æ‹’ç»å›¢é˜Ÿç»“æ„ä¸è¶³çš„å‡çº§è¯·æ±‚', async () => {
        // Arrange
        const userId = 123;
        const mockUser = {
          id: userId,
          level: 'normal',
          totalSales: 12000, // æ»¡è¶³é”€é‡è¦æ±‚
          teamStructure: { levelDistribution: { star_1: 1 } } // åªæœ‰1ä¸ªä¸€æ˜Ÿï¼Œéœ€è¦2ä¸ª
        };
        userService.getUserById.mockResolvedValue(mockUser);

        // Act
        const result = await upgradeService.checkUpgradeConditions(userId);

        // Assert
        expect(result.canUpgrade).toBe(false);
        expect(result.requirements.teamRequirements).toEqual([
          { level: 'star_1', count: 2, required: true }
        ]);
      });

      it('åº”è¯¥æ­£ç¡®å¤„ç†VIPç”¨æˆ·ç›´é€šåº—å‡çº§', async () => {
        // Arrange
        const userId = 123;
        const mockUser = {
          id: userId,
          level: 'vip',
          totalSales: 27000, // äº”é€šåº—è´­ä¹°é‡‘é¢
          teamStructure: { levelDistribution: {} }
        };
        userService.getUserById.mockResolvedValue(mockUser);

        // Act
        const result = await upgradeService.checkWutongDirectUpgrade(userId);

        // Assert
        expect(result.canUpgrade).toBe(true);
        expect(result.targetLevel).toBe('star_2');
      });
    });
  });

  describe('executeUpgrade', () => {
    it('åº”è¯¥æˆåŠŸæ‰§è¡Œç”¨æˆ·ç­‰çº§å‡çº§', async () => {
      // Arrange
      const userId = 123;
      const upgradeData = {
        targetLevel: 'star_2',
        approvedBy: 456
      };

      // Act
      await upgradeService.executeUpgrade(userId, upgradeData);

      // Assert
      expect(userService.updateUserLevel).toHaveBeenCalledWith(userId, 'star_2');
      expect(userService.createUpgradeRecord).toHaveBeenCalled();
    });

    it('åº”è¯¥è§¦å‘ç›¸å…³é€šçŸ¥', async () => {
      // Arrange
      const userId = 123;
      const upgradeData = {
        targetLevel: 'star_2',
        approvedBy: 456
      };

      // Act
      await upgradeService.executeUpgrade(userId, upgradeData);

      // Assert
      expect(upgradeService.notificationService.sendUpgradeNotification).toHaveBeenCalled();
    });
  });
});
```

### å•å…ƒæµ‹è¯•æœ€ä½³å®è·µ

```typescript
// 1. ä½¿ç”¨æè¿°æ€§çš„æµ‹è¯•åç§°
describe('ä¸šåŠ¡åœºæ™¯æè¿°', () => {
  test('å…·ä½“çš„é¢„æœŸè¡Œä¸º', () => {
    // æµ‹è¯•é€»è¾‘
  });
});

// 2. ä½¿ç”¨Arrange-Act-Assertæ¨¡å¼
test('åº”è¯¥è¿”å›æ­£ç¡®ç»“æœ', () => {
  // Arrange - å‡†å¤‡æµ‹è¯•æ•°æ®
  const input = createTestData();

  // Act - æ‰§è¡Œè¢«æµ‹è¯•çš„æ“ä½œ
  const result = functionUnderTest(input);

  // Assert - éªŒè¯ç»“æœ
  expect(result).toEqual(expectedResult);
});

// 3. æ¨¡æ‹Ÿå¤–éƒ¨ä¾èµ–
jest.mock('../../../src/services/user');
const mockUserService = new UserService() as jest.Mocked<UserService>;

// 4. æµ‹è¯•è¾¹ç•Œæ¡ä»¶
test('åº”è¯¥å¤„ç†ç©ºå€¼è¾“å…¥', () => {
  expect(() => functionUnderTest(null)).toThrow();
});
```

---

## ğŸ”§ é›†æˆæµ‹è¯•ç­–ç•¥

### é›†æˆæµ‹è¯•èŒƒå›´

```typescript
// tests/integration/purchase-flow.test.ts
describe('é‡‡è´­æµç¨‹é›†æˆæµ‹è¯•', () => {
  describe('å®Œæ•´é‡‡è´­æµç¨‹', () => {
    test('ç”¨æˆ·åº”è¯¥èƒ½å¤Ÿå®Œæˆå®Œæ•´é‡‡è´­æµç¨‹', async () => {
      // 1. ç”¨æˆ·ç™»å½•è·å–Token
      const loginResponse = await request(app)
        .post('/v1/auth/login')
        .send({ openid: 'test_openid' })
        .expect(201);

      const token = loginResponse.body.data.access_token;

      // 2. éªŒè¯é‡‡è´­æƒé™
      const permissionResult = await request(app)
        .post('/v1/purchases/validate-permission')
        .set('Authorization', `Bearer ${token}`)
        .send({
          buyer_id: 123,
          seller_id: 456,
          product_id: 1,
          quantity: 10
        })
        .expect(200);

      expect(permissionResult.body.data.valid).toBe(true);

      // 3. åˆ›å»ºé‡‡è´­è®¢å•
      const purchaseResponse = await request(app)
        .post('/v1/purchases')
        .set('Authorization', `Bearer ${token}`)
        .send({
          buyer_id: 123,
          seller_id: 456,
          product_id: 1,
          quantity: 10
        })
        .expect(201);

      const purchaseId = purchaseResponse.body.data.id;

      // 4. æ”¯ä»˜é€šåˆ¸
      const paymentResponse = await request(app)
        .post('/v1/purchases/pay')
        .set('Authorization', `Bearer ${token}`)
        .send({
          purchase_id: purchaseId,
          payment_method: 'points'
        })
        .expect(200);

      // 5. éªŒè¯åº“å­˜å˜åŒ–
      const inventoryResponse = await request(app)
        .get(`/v1/inventory/user/${456}/cloud/1`)
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      expect(inventoryResponse.body.data.quantity).toBe(90); // åŸåº“å­˜100ï¼Œå”®å‡º10
    });
  });
});
```

### æ•°æ®åº“é›†æˆæµ‹è¯•

```typescript
// tests/integration/database.test.ts
describe('æ•°æ®åº“é›†æˆæµ‹è¯•', () => {
  beforeAll(async () => {
    // è®¾ç½®æµ‹è¯•æ•°æ®åº“
    await setupTestDatabase();
  });

  afterAll(async () => {
    // æ¸…ç†æµ‹è¯•æ•°æ®åº“
    await cleanupTestDatabase();
  });

  describe('ç”¨æˆ·æ•°æ®æŒä¹…åŒ–', () => {
    test('åº”è¯¥æ­£ç¡®ä¿å­˜å’Œè¯»å–ç”¨æˆ·ä¿¡æ¯', async () => {
      // åˆ›å»ºç”¨æˆ·
      const userData = {
        openid: 'test_openid',
        nickname: 'æµ‹è¯•ç”¨æˆ·',
        level: 'normal',
        phone: '13800138000'
      };

      const createdUser = await prisma.user.create({ data: userData });
      expect(createdUser.id).toBeDefined();
      expect(createdUser.nickname).toBe(userData.nickname);

      // è¯»å–ç”¨æˆ·
      const retrievedUser = await prisma.user.findUnique({
        where: { id: createdUser.id }
      });

      expect(retrievedUser).not.toBeNull();
      expect(retrievedUser.nickname).toBe(userData.nickname);
    });

    test('åº”è¯¥æ­£ç¡®ç»´æŠ¤ç”¨æˆ·ç­‰çº§å‡çº§å†å²', async () => {
      // åˆ›å»ºç”¨æˆ·
      const user = await createTestUser();

      // æ‰§è¡Œå‡çº§
      await upgradeUserLevel(user.id, 'star_1');

      // éªŒè¯ç­‰çº§
      const updatedUser = await prisma.user.findUnique({
        where: { id: user.id }
      });
      expect(updatedUser.level).toBe('star_1');

      // éªŒè¯å‡çº§è®°å½•
      const upgradeRecord = await prisma.userLevelRecord.findFirst({
        where: { user_id: user.id }
      });
      expect(upgradeRecord).not.toBeNull();
      expect(upgradeRecord.from_level).toBe('normal');
      expect(upgradeRecord.to_level).toBe('star_1');
    });
  });
});
```

---

## ğŸŒ E2Eæµ‹è¯•ç­–ç•¥

### å…³é”®ä¸šåŠ¡æµç¨‹æµ‹è¯•

```typescript
// tests/e2e/user-journey.test.ts
describe('ç”¨æˆ·å®Œæ•´æ—…ç¨‹æµ‹è¯•', () => {
  let user: User;
  let shop: Shop;

  test('æ–°ç”¨æˆ·å®Œæˆä»æ³¨å†Œåˆ°å¼€åº—çš„å…¨æµç¨‹', async () => {
    // 1. ç”¨æˆ·æ³¨å†Œ
    const registrationResponse = await page.goto('/pages/register');
    await page.fill('[data-testid="nickname-input"]', 'æµ‹è¯•ç”¨æˆ·');
    await page.fill('[data-testid="phone-input"]', '13800138000');
    await page.click('[data-testid="register-button"]');
    await expect(page.locator('[data-testid="success-message"]')).toBeVisible();

    // 2. é¦–æ¬¡è´­ä¹°æˆä¸ºVIP
    await page.goto('/pages/products');
    await page.click('[data-testid="product-ç»ç»œé€š"]');
    await page.click('[data-testid="buy-button"]');
    await page.click('[data-testid="pay-button"]');
    await expect(page.locator('[data-testid="vip-badge"]')).toBeVisible();

    // 3. ç”³è¯·å¼€åº—
    await page.goto('/pages/shop/apply');
    await page.fill('[data-testid="shop-name"]', 'æµ‹è¯•åº—é“º');
    await page.uploadFile('[data-testid="business-license"]', 'test-docs/license.jpg');
    await page.click('[data-testid="submit-application"]');

    // 4. ç­‰å¾…å®¡æ ¸é€šè¿‡
    await page.waitForSelector('[data-testid="shop-approved"]');
    await expect(page.locator('[data-testid="shop-status"]')).toContain('å·²å¼€é€š');

    // 5. éªŒè¯åº—é“ºåŠŸèƒ½
    await expect(page.locator('[data-testid="shop-management"]')).toBeVisible();
    await expect(page.locator('[data-testid="inventory-management"]')).toBeVisible();
  });
});
```

### æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•

```typescript
// tests/e2e/core-features.test.ts
describe('æ ¸å¿ƒåŠŸèƒ½E2Eæµ‹è¯•', () => {
  describe('ç”¨æˆ·ç­‰çº§ç³»ç»Ÿ', () => {
    test('ç”¨æˆ·åº”è¯¥èƒ½å¤Ÿä»æ™®é€šä¼šå‘˜å‡çº§åˆ°è‘£äº‹', async () => {
      // æ¨¡æ‹Ÿå®Œæ•´çš„å‡çº§è·¯å¾„
      await simulateUserUpgradePath('normal', 'director');

      // éªŒè¯æ¯ä¸ªç­‰çº§çš„æƒé™å’ŒåŠŸèƒ½
      await verifyLevelPermissions('normal');
      await simulateAndVerifyUpgrade('normal', 'vip');
      await verifyLevelPermissions('vip');
      await simulateAndVerifyUpgrade('vip', 'star_1');
      // ... ç»§ç»­åˆ°è‘£äº‹
    });
  });

  describe('é‡‡è´­æƒé™ç³»ç»Ÿ', () => {
    test('åº”è¯¥ä¸¥æ ¼æ‰§è¡Œé‡‡è´­æƒé™è§„åˆ™', async () => {
      // åˆ›å»ºç”¨æˆ·å’Œåº—é“º
      const buyer = await createTestUser('star_1');
      const seller = await createTestUser('star_2');
      const peer = await createTestUser('star_1');

      // éªŒè¯æœ‰æ•ˆé‡‡è´­
      const validPurchase = await createPurchase(buyer.id, seller.id, 10);
      expect(validPurchase.status).toBe('completed');

      // éªŒè¯å¹³çº§é‡‡è´­æ‹’ç»
      const peerPurchase = await createPurchase(peer.id, buyer.id, 10);
      expect(peerPurchase.status).toBe('failed');
      expect(peerPurchase.error.code).toBe('PURCHASE_INVALID_PERMISSION');

      // éªŒè¯ä¸‹çº§é‡‡è´­æ‹’ç»
      const invalidPurchase = await createPurchase(seller.id, buyer.id, 10);
      expect(invalidPurchase.status).toBe('failed');
    });
  });

  describe('é€šåˆ¸æµè½¬ç³»ç»Ÿ', () => {
    test('åº”è¯¥æ­£ç¡®å¤„ç†é€šåˆ¸è½¬è´¦', async () => {
      const fromUser = await createTestUser('star_3');
      const toUser = await createTestUser('star_1');

      // åˆå§‹ä½™é¢æ£€æŸ¥
      const initialBalance = await getPointsBalance(fromUser.id);
      expect(initialBalance).toBeGreaterThan(1000);

      // æ‰§è¡Œè½¬è´¦
      const transferResponse = await transferPoints(
        fromUser.id,
        toUser.id,
        500,
        'æµ‹è¯•è½¬è´¦'
      );
      expect(transferResponse.success).toBe(true);

      // éªŒè¯ä½™é¢å˜åŒ–
      const finalFromBalance = await getPointsBalance(fromUser.id);
      const finalToBalance = await getPointsBalance(toUser.id);

      expect(finalFromBalance).toBe(initialBalance - 500);
      expect(finalToBalance).toBeGreaterThan(0);
    });
  });
});
```

### æµ‹è¯•å·¥å…·ç±»

```typescript
// tests/helpers/test-utils.ts
export class TestUtils {
  static async createTestUser(overrides?: Partial<User>): Promise<User> {
    const userData = {
      openid: `test_${Date.now()}`,
      nickname: 'æµ‹è¯•ç”¨æˆ·',
      level: 'normal',
      status: 'active',
      totalSales: 0,
      ...overrides
    };

    return prisma.user.create({ data: userData });
  }

  static async createTestShop(userId: number, overrides?: Partial<Shop>): Promise<Shop> {
    const shopData = {
      userId,
      shopName: 'æµ‹è¯•åº—é“º',
      shopType: 'cloud',
      shopLevel: 1,
      shopStatus: 'active',
      ...overrides
    };

    return prisma.shop.create({ data: shopData });
  }

  static async createPurchase(
    buyerId: number,
    sellerId: number,
    quantity: number,
    overrides?: Partial<Purchase>
  ): Promise<Purchase> {
    const purchaseData = {
      buyerId,
      sellerId,
      productId: 1, // å‡è®¾äº§å“ID
      productName: 'ç»ç»œé€š',
      quantity,
      unitPrice: 239.6, // ä¸€æ˜Ÿåº—é•¿ä»·æ ¼
      totalAmount: quantity * 239.6,
      status: 'pending',
      ...overrides
    };

    return prisma.purchase.create({ data: purchaseData });
  }

  static async transferPoints(
    fromUserId: number,
    toUserId: number,
    amount: number,
    description: string
  ): Promise<TransferResult> {
    return request(app)
      .post('/v1/points/transfer')
      .send({
        from_user_id: fromUserId,
        to_user_id: toUserId,
        amount,
        description
      });
  }

  static async getPointsBalance(userId: number): Promise<number> {
    const response = await request(app)
      .get(`/v1/points/balance?user_id=${userId}`);
    return response.body.data.balance;
  }

  static async sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## âš¡ æ€§èƒ½æµ‹è¯•ç­–ç•¥

### è´Ÿè½½æµ‹è¯•æŒ‡æ ‡

```typescript
interface PerformanceMetrics {
  response_time: number;      // å“åº”æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  throughput: number;         // ååé‡ï¼ˆè¯·æ±‚/ç§’ï¼‰
  concurrent_users: number;     // å¹¶å‘ç”¨æˆ·æ•°
  error_rate: number;          // é”™è¯¯ç‡
  resource_usage: {
    cpu: number;              // CPUä½¿ç”¨ç‡
    memory: number;           // å†…å­˜ä½¿ç”¨ç‡
    database: number;         // æ•°æ®åº“è¿æ¥æ•°
  };
}
```

### k6æµ‹è¯•è„šæœ¬

```javascript
// tests/performance/load-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

export let errorRate = new Rate('errors');

export const options = {
  stages: [
    { duration: '2m', target: 20 },
    { duration: '5m', target: 50 },
    { duration: '10m', target: 100 },
    { duration: '20m', target: 200 },
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'],
    http_req_failed: ['rate<0.01'],
    checks: ['status==200'],
  },
};

export default function() {
  // è·å–ç”¨æˆ·ä¿¡æ¯æ¥å£
  export let getUserInfo = () => {
    let responses = http.get(`http://localhost:3000/v1/users/profile`, {
      headers: {
        'Authorization': 'Bearer ' + __ENV.API_TOKEN,
      },
    });

    check(responses, {
      'status is 200': (r) => r.status === 200,
      'response time < 500ms': (r) => r.timings.duration < 500,
    });

    return responses;
  };

  // åˆ›å»ºé‡‡è´­è®¢å•æ¥å£
  export let createPurchase = () => {
    let responses = http.post(`http://localhost:3000/v1/purchases`, {
      headers: {
        'Authorization': 'Bearer ' + __ENV.API_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        buyer_id: Math.floor(Math.random() * 1000) + 1,
        seller_id: Math.floor(Math.random() * 1000) + 1,
        product_id: 1,
        quantity: Math.floor(Math.random() * 20) + 1
      }),
    });

    check(responses, {
      'status is 200': (r) => r.status === 200,
      'response time < 1000ms': (r) => r.timings.duration < 1000,
    });

    return responses;
  };

  // è½¬è´¦é€šåˆ¸æ¥å£
  export let transferPoints = () => {
    let responses = http.post(`http://localhost:3000/v1/points/transfer`, {
      headers: {
        'Authorization': 'Bearer ' + __ENV.API_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        from_user_id: Math.floor(Math.random() * 1000) + 1,
        to_user_id: Math.floor(Math.random() * 1000) + 1,
        amount: Math.floor(Math.random() * 1000) + 1,
        description: 'æ€§èƒ½æµ‹è¯•è½¬è´¦'
      }),
    });

    check(responses, {
      'status is 200': (r) => r.status === 200,
      'response time < 800ms': (r) => r.timings.duration < 800,
    });

    return responses;
  };

  // æµ‹è¯•åœºæ™¯ï¼šæ··åˆè´Ÿè½½
  export default function() {
    // 70% ç”¨æˆ·ä¿¡æ¯è¯·æ±‚
    group('ç”¨æˆ·ä¿¡æ¯æŸ¥è¯¢', () => {
      getUserInfo();
    });

    // 20% é‡‡è´­è®¢å•åˆ›å»º
    group('é‡‡è´­è®¢å•', () => {
      createPurchase();
    });

    // 10% é€šåˆ¸è½¬è´¦
    group('é€šåˆ¸è½¬è´¦', () => {
      transferPoints();
    });
  }
}
```

### å‹åŠ›æµ‹è¯•

```typescript
// tests/performance/stress-test.ts
describe('ç³»ç»Ÿå‹åŠ›æµ‹è¯•', () => {
  test('ç³»ç»Ÿåº”è¯¥æ”¯æŒ1000å¹¶å‘ç”¨æˆ·', async () => {
    const promises = [];

    // åˆ›å»º1000ä¸ªå¹¶å‘è¯·æ±‚
    for (let i = 0; i < 1000; i++) {
      promises.push(
        request(app)
          .get('/v1/users/profile')
          .set('Authorization', `Bearer ${testToken}`)
          .expect(200)
      );
    }

    const results = await Promise.allSettled(promises);
    const successful = results.filter(r => r.status === 'fulfilled').length;
    const failed = results.filter(r => r.status === 'rejected').length;

    expect(successful).toBeGreaterThan(950); // 95%æˆåŠŸç‡
    expect(failed).toBeLessThan(50);      // 5%å¤±è´¥ç‡
  });

  test('ç³»ç»Ÿåº”è¯¥åœ¨é«˜è´Ÿè½½ä¸‹ä¿æŒå“åº”æ—¶é—´', async () => {
    const startTime = Date.now();

    const response = await request(app)
      .get('/v1/users/profile')
      .set('Authorization', `Bearer ${testToken}`)
      .expect(200);

    const endTime = Date.now();
    const responseTime = endTime - startTime;

    expect(responseTime).toBeLessThan(2000); // 2ç§’å†…å“åº”
  });
});
```

---

## ğŸ” å®‰å…¨æµ‹è¯•ç­–ç•¥

### å®‰å…¨æµ‹è¯•èŒƒå›´

```typescript
interface SecurityTestType {
  authentication: boolean;    // è®¤è¯æµ‹è¯•
  authorization: boolean;    // æˆæƒæµ‹è¯•
  input_validation: boolean;  // è¾“å…¥éªŒè¯æµ‹è¯•
  sql_injection: boolean;    // SQLæ³¨å…¥æµ‹è¯•
  xss_protection: boolean;   // XSSé˜²æŠ¤æµ‹è¯•
  rate_limiting: boolean;    // é™æµæµ‹è¯•
  data_encryption: boolean;  // æ•°æ®åŠ å¯†æµ‹è¯•
  api_security: boolean;     // APIå®‰å…¨æµ‹è¯•
}
```

### è®¤è¯æµ‹è¯•

```typescript
// tests/security/authentication.test.ts
describe('è®¤è¯å®‰å…¨æµ‹è¯•', () => {
  describe('JWT Tokenå®‰å…¨', () => {
    test('åº”è¯¥æ‹’ç»æ— æ•ˆToken', async () => {
      const response = await request(app)
        .get('/v1/users/profile')
        .set('Authorization', 'Bearer invalid_token')
        .expect(401);
    });

    test('åº”è¯¥æ‹’ç»è¿‡æœŸToken', async () => {
      const expiredToken = generateExpiredToken();
      const response = await request(app)
        .get('/v1/users/profile')
        .set('Authorization', `Bearer ${expiredToken}`)
        .expect(401);
    });

    test('åº”è¯¥æ‹’ç»è¢«æ’¤é”€çš„Token', async () => {
      const revokedToken = generateRevokedToken();
      const response = await request(app)
        .get('/v1/users/profile')
        .set('Authorization', `Bearer ${revokedToken}`)
        .expect(401);
    });
  });

  describe('æƒé™æ§åˆ¶', () => {
    test('æ™®é€šç”¨æˆ·æ— æ³•è®¿é—®ç®¡ç†å‘˜æ¥å£', async () => {
      const userToken = generateUserToken('normal');

      const response = await request(app)
        .get('/v1/admin/users')
        .set('Authorization', `Bearer ${userToken}`)
        .expect(403);
    });

    test('ç”¨æˆ·åªèƒ½æ›´æ–°è‡ªå·±çš„ä¿¡æ¯', async () => {
      const userToken = generateUserToken('normal');
      const otherUserId = 999999;

      // å°è¯•æ›´æ–°å…¶ä»–ç”¨æˆ·ä¿¡æ¯
      const response = await request(app)
        .patch(`/v1/users/${otherUserId}`)
        .set('Authorization', `Bearer ${userToken}`)
        .send({ nickname: 'è¢«ä¿®æ”¹çš„æ˜µç§°' })
        .expect(403);

      // éªŒè¯å¯ä»¥æ›´æ–°è‡ªå·±çš„ä¿¡æ¯
      const selfResponse = await request(app)
        .patch('/v1/users/profile')
        .set('Authorization', `Bearer ${userToken}`)
        .send({ nickname: 'æ–°æ˜µç§°' })
        .expect(200);
    });
  });
});
```

### ä¸šåŠ¡é€»è¾‘å®‰å…¨æµ‹è¯•

```typescript
// tests/security/business-logic-security.test.ts
describe('ä¸šåŠ¡é€»è¾‘å®‰å…¨æµ‹è¯•', () => {
  describe('é‡‡è´­æƒé™éªŒè¯', () => {
    test('åº”è¯¥é˜²æ­¢éæ³•é‡‡è´­', async () => {
      const userToken = generateUserToken('star_1');

      // å°è¯•ä»ä½ç­‰çº§ç”¨æˆ·é‡‡è´­
      const response = await request(app)
        .post('/v1/purchases')
        .set('Authorization', `Bearer ${userToken}`)
        .send({
          buyer_id: 123, // star_1ç”¨æˆ·
          seller_id: 456, // star_1ç”¨æˆ·ï¼ˆå¹³çº§ï¼‰
          product_id: 1,
          quantity: 10
        })
        .expect(422);

      expect(response.body.error.code).toBe('PURCHASE_INVALID_PERMISSION');
    });

    test('åº”è¯¥é˜²æ­¢ç»•è¿‡é‡‡è´­é™åˆ¶', async () => {
      const userToken = generateUserToken('star_1');
      const sellerToken = generateUserToken('star_3');

      // å°è¯•ä¿®æ”¹è¯·æ±‚å‚æ•°ç»•è¿‡éªŒè¯
      const response = await request(app)
        .post('/v1/purchases/validate-permission')
        .set('Authorization', `Bearer ${userToken}`)
        .send({
          buyer_id: 123,
          seller_id: 456,
          bypass_validation: true  // å°è¯•ç»•è¿‡éªŒè¯
        })
        .expect(400);

      expect(response.body.error.code).toBe('INVALID_REQUEST');
    });
  });

  describe('é€šåˆ¸å®‰å…¨æµ‹è¯•', () => {
    test('åº”è¯¥é˜²æ­¢ä½™é¢ä¸è¶³è½¬è´¦', async () => {
      const userToken = generateUserToken('star_1');
      const initialBalance = await getPointsBalance(123);

      // å°è¯•è½¬è´¦è¶…å‡ºä½™é¢
      const response = await request(app)
        .post('/v1/points/transfer')
        .set('authorization', `Bearer ${userToken}`)
        .send({
          from_user_id: 123,
          to_user_id: 456,
          amount: initialBalance + 100 // è¶…å‡ºä½™é¢
        })
        .expect(400);

      expect(response.body.error.code).toBe('POINTS_INSUFFICIENT_BALANCE');
    });

    test('åº”è¯¥é˜²æ­¢å¤§é¢è½¬è´¦é£é™©', async () => {
      const userToken = generateUserToken('star_1');

      // å°è¯•å¤§é¢è½¬è´¦
      const response = await request(app)
        .post('/v1/points/transfer')
        .set('authorization', `Bearer ${userToken}`)
        .send({
          from_user_id: 123,
          to_user_id: 456,
          amount: 1000000 // 100ä¸‡é€šåˆ¸
        })
        .expect(400);

      expect(response.body.error.code).toBe('POINTS_TRANSFER_LIMIT_EXCEEDED');
    });
  });
});
```

---

## ğŸ“Š æµ‹è¯•æŠ¥å‘Š

### æµ‹è¯•æŠ¥å‘Šæ¨¡æ¿

```typescript
interface TestReport {
  summary: {
    total_tests: number;
    passed: number;
    failed: number;
    skipped: number;
    coverage: TestCoverage;
  };
  details: TestDetail[];
  performance: PerformanceMetrics;
  security: SecurityMetrics;
}

interface TestCoverage {
  statements: {
    total: number;
    covered: number;
    percentage: number;
  };
  branches: {
    total: number;
    covered: number;
    percentage: number;
  };
  functions: {
    total: number;
    covered: number;
    percentage: number;
  };
  lines: {
    total: number;
    covered: number;
    percentage: number;
  };
}

interface TestDetail {
  suite: string;
  test: string;
  status: 'passed' | 'failed' | 'skipped';
  duration: number;
  error?: string;
  stack?: string;
}
```

### æµ‹è¯•æŠ¥å‘Šç”Ÿæˆ

```typescript
// scripts/generate-test-report.ts
import { TestReport } from '../types/test-report';

export class TestReportGenerator {
  generateReport(
    testResults: TestDetail[],
    coverageData: any,
    performanceData: any,
    securityData: any
  ): TestReport {
    const totalTests = testResults.length;
    const passed = testResults.filter(t => t.status === 'passed').length;
    const failed = testResults.filter(t => t.status === 'failed').length;
    const skipped = testResults.filter(t => t.status === 'skipped').length;

    return {
      summary: {
        total_tests,
        passed,
        failed,
        skipped,
        coverage: this.parseCoverage(coverageData)
      },
      details: testResults,
      performance: performanceData,
      security: securityData
    };
  }

  private parseCoverage(coverageData: any): TestCoverage {
    return {
      statements: {
        total: coverageData.totalStatements,
        covered: coverageData.coveredStatements,
        percentage: (coverageData.coveredStatements / coverageData.totalStatements) * 100
      },
      branches: {
        total: coverageData.totalBranches,
        covered: coverageData.coveredBranches,
        percentage: (coverageData.coveredBranches / coverageData.totalBranches) * 100
      },
      functions: {
        total: coverageData.totalFunctions,
        covered: coverageData.coveredFunctions,
        percentage: (coverageData.coveredFunctions / coverageData.totalFunctions) * 100
      },
      lines: {
        total: coverageData.totalLines,
        covered: coverageData.coveredLines,
        percentage: (coverageData.coveredLines / coverageData.totalLines) * 100
      }
    };
  }
}
```

---

## ğŸ› ï¸ è´¨é‡ä¿è¯æµç¨‹

### ä»£ç å®¡æŸ¥è§„èŒƒ

```typescript
// .github/workflows/code-review.yml
name: Code Review
on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - name: æ£€æŸ¥ä»£ç è§„èŒƒ
        run: |
          npm run lint:check
          npm run type-check

      - name: è¿è¡Œæµ‹è¯•
        run: |
          npm run test:unit
          npm run test:integration

      - name: ä»£ç å®¡æŸ¥
        run: |
          echo "å¼€å§‹ä»£ç å®¡æŸ¥..."
          # AIè‡ªåŠ¨ä»£ç å®¡æŸ¥
          npx ts-node scripts/auto-code-review.ts

      - name: ä¸šåŠ¡é€»è¾‘éªŒè¯
        run: |
          echo "éªŒè¯ä¸šåŠ¡é€»è¾‘..."
          npx ts-node scripts/validate-business-logic.ts
```

### CI/CDè´¨é‡é—¨ç¦

```yaml
# .github/workflows/quality-gates.yml
name: Quality Gates
on:
  pull_request:
    types: [opened, synchronize]

jobs:
  quality-gates:
    runs-on: ubuntu-latest
    steps:
      - name: å•å…ƒæµ‹è¯•æ£€æŸ¥
        run: npm run test:unit
        env:
          COVERAGE_THRESHOLD: 80

      - name: é›†æˆæµ‹è¯•æ£€æŸ¥
        run: npm run test:integration

      - name: ä»£ç è¦†ç›–ç‡æ£€æŸ¥
        run: npm run test:coverage
        env:
          MIN_COVERAGE: 80

      - name: å®‰å…¨æ‰«æ
        run: npm run security:scan

      - name: æ€§èƒ½æµ‹è¯•
        run: npm run test:performance

      - name: ä¸šåŠ¡é€»è¾‘éªŒè¯
        run: npm run test:business-logic
```

### å‘å¸ƒè´¨é‡æ£€æŸ¥æ¸…å•

```typescript
interface ReleaseChecklist {
  code_quality: {
    linting: boolean;
    type_checking: boolean;
    test_coverage: boolean;
    security_scan: boolean;
  };

  functionality: {
    unit_tests_passed: boolean;
    integration_tests_passed: boolean;
    e2e_tests_passed: boolean;
    api_tests_passed: boolean;
  };

  performance: {
    response_time_ok: boolean;
    throughput_ok: boolean;
    resource_usage_ok: boolean;
  };

  security: {
    vulnerability_scan_passed: boolean;
    penetration_tests_passed: boolean;
    data_encryption_verified: boolean;
  };

  documentation: {
    api_docs_updated: boolean;
    user_docs_updated: boolean;
    deployment_docs_updated: boolean;
  };
}
```

---

## ğŸ“‹ æµ‹è¯•å·¥å…·é…ç½®

### Jesté…ç½®

```json
{
  "jest": {
    "preset": "ts-jest",
    "testEnvironment": "node",
    "roots": [
      "<rootDir>/tests"
    ],
    "testMatch": [
      "**/__tests__/**/*.ts",
      "**/test/**/*.test.ts"
    ],
    "testPathIgnorePatterns": [
      "/node_modules/",
      "/dist/",
      "/build/"
    ],
    "collectCoverage": true,
    "coverageDirectory": "coverage",
    "coverageReporters": [
      "text",
      "lcov",
      "html"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 75,
        "functions": 85,
        "lines": 80,
        "statements": 80
      }
    },
    "setupFilesAfterEnv": [
      "<rootDir>/tests/setup.ts"
    ],
    "testTimeout": 30000
  }
}
```

### æµ‹è¯•ç¯å¢ƒé…ç½®

```typescript
// tests/setup.ts
import { PrismaClient } from '@prisma/client';
import { TestDatabase } from './helpers/test-database';

// å…¨å±€æµ‹è¯•è®¾ç½®
beforeAll(async () => {
  console.log('ğŸš€ å¼€å§‹æµ‹è¯•ç¯å¢ƒåˆå§‹åŒ–...');

  // è®¾ç½®æµ‹è¯•æ•°æ®åº“
  await TestDatabase.setup();

  // è®¾ç½®æµ‹è¯•åº”ç”¨
  await setupTestApp();

  console.log('âœ… æµ‹è¯•ç¯å¢ƒåˆå§‹åŒ–å®Œæˆ');
});

afterAll(async () => {
  console.log('ğŸ§¹ æ¸…ç†æµ‹è¯•ç¯å¢ƒ...');

  await TestDatabase.cleanup();
  await cleanupTestApp();

  console.log('âœ… æµ‹è¯•ç¯å¢ƒæ¸…ç†å®Œæˆ');
});

beforeEach(async () => {
  // æ¯ä¸ªæµ‹è¯•å‰æ¸…ç†æ•°æ®
  await cleanupTestData();
});

afterEach(async () => {
  // æ¯ä¸ªæµ‹è¯•åéªŒè¯æ•°æ®ä¸€è‡´æ€§
  await validateDataConsistency();
});
```

---

## ğŸ“‹ æµ‹è¯•æ‰§è¡Œè®¡åˆ’

### æ¯æ—¥æµ‹è¯•

```typescript
// scripts/daily-tests.ts
export const dailyTests = {
  unit: {
    coverage: 'full',
    suites: [
      'user-services',
      'shop-services',
      'purchase-services',
      'points-services'
    ]
  },
  integration: {
    coverage: 'targeted',
    suites: [
      'auth-flow',
      'purchase-flow',
      'points-flow'
    ]
  },
  api: {
    coverage: 'smoke',
    endpoints: [
      '/v1/users/profile',
      '/v1/shops/info',
      '/v1/points/balance'
    ]
  }
};
```

### æ¯å‘¨æµ‹è¯•

```typescript
// scripts/weekly-tests.ts
export const weeklyTests = {
  e2e: {
    scenarios: [
      'user-complete-journey',
      'shop-management',
      'purchase-management',
      'points-management',
      'inventory-management'
    ]
  },
  performance: {
    load_tests: [
      'user-peak-load',
      'purchase-peak-load',
      'points-transfer-load'
    ],
    stress_tests: [
      'concurrent-users',
      'database-stress',
      'api-stress'
    ]
  },
  security: [
    'authentication-security',
    'authorization-security',
    'input-validation',
    'sql-injection',
    'xss-protection',
    'rate-limiting'
  ]
};
```

### æ¯æœˆæµ‹è¯•

```typescript
// scripts/monthly-tests.ts
export const monthlyTests = {
  comprehensive: {
    all_suites: true,
    coverage_target: 90
  },
  regression: {
    critical_paths: [
      'user-upgrade-path',
      'purchase-logic',
      'points-calculation',
      'inventory-flow'
    ]
  },
  performance: {
    full_load_test: true,
    capacity_planning: true,
    bottleneck_analysis: true
  },
  security: [
    'penetration_testing',
    'vulnerability_assessment',
    'compliance_checking'
  ]
};
```

---

## ğŸ“‹ æµ‹è¯•æ£€æŸ¥æ¸…å•

### æµ‹è¯•å‰æ£€æŸ¥

- [ ] æµ‹è¯•ç¯å¢ƒå‡†å¤‡å®Œæˆ
- [ ] æµ‹è¯•æ•°æ®åº“åˆå§‹åŒ–
- [ ] æµ‹è¯•åº”ç”¨å¯åŠ¨æ­£å¸¸
- [ ] æµ‹è¯•æ•°æ®å’Œå·¥å…·å‡†å¤‡

### å•å…ƒæµ‹è¯•æ£€æŸ¥

- [ ] æµ‹è¯•ç”¨ä¾‹ç¼–å†™å®Œæ•´
- [ ] è¾¹ç•Œæ¡ä»¶è¦†ç›–å…¨é¢
- [ ] Mockå¯¹è±¡è®¾ç½®æ­£ç¡®
- [ ] æ–­è¨€éªŒè¯å‡†ç¡®
- [ ] æµ‹è¯•æè¿°æ¸…æ™°

### é›†æˆæµ‹è¯•æ£€æŸ¥

- [ ] æ•°æ®åº“è¿æ¥æ­£å¸¸
- [ APIæ¥å£å¯ç”¨
- [ ] å¤–éƒ¨æœåŠ¡Mockå®Œæ•´
- [ ] æµ‹è¯•æ•°æ®å‡†å¤‡å……åˆ†
- [ ] æ¸…ç†æœºåˆ¶å®Œå–„

### E2Eæµ‹è¯•æ£€æŸ¥

- [ ] æµè§ˆå™¨ç¯å¢ƒå‡†å¤‡
- [   ç”¨æˆ·è´¦å·å‡†å¤‡
- [   æµ‹è¯•æ•°æ®å‡†å¤‡
- [   é¡µé¢å…ƒç´ å¯è®¿é—®
- [   ç½‘ç»œè¿æ¥ç¨³å®š

### æ€§èƒ½æµ‹è¯•æ£€æŸ¥

- [ ] æµ‹è¯•åœºæ™¯è®¾è®¡åˆç†
- [   è´Ÿè½½æ¨¡å‹ç¬¦åˆå®é™…
-   ç›‘æ§æŒ‡æ ‡è®¾ç½®æ­£ç¡®
-   åŸºå‡†æ•°æ®æ”¶é›†å®Œæˆ

### å®‰å…¨æµ‹è¯•æ£€æŸ¥

- [ ] å®‰å…¨æµ‹è¯•ç”¨ä¾‹è¦†ç›–
- [   æ¼æ´æ‰«æå®Œæˆ
-   æ¸—é€æµ‹è¯•å‡†å¤‡å……åˆ†
-   å®‰å…¨å·¥å…·é…ç½®æ­£ç¡®

---

**é‡è¦æé†’**ï¼š
1. æ‰€æœ‰æµ‹è¯•å¿…é¡»ç»è¿‡æµ‹è¯•AIå®¡æŸ¥
2. å…³é”®ä¸šåŠ¡é€»è¾‘å¿…é¡»æœ‰100%è¦†ç›–ç‡
3. æ€§èƒ½æµ‹è¯•å¿…é¡»æ¨¡æ‹ŸçœŸå®åœºæ™¯
4. å®‰å…¨æµ‹è¯•å¿…é¡»åŒ…å«è‡ªåŠ¨åŒ–æ‰«æ
5. æµ‹è¯•æŠ¥å‘Šå¿…é¡»åŠæ—¶ç”Ÿæˆå’Œåˆ†å‘
6. æµ‹è¯•å¤±è´¥å¿…é¡»åŠæ—¶ä¿®å¤å¹¶é‡æ–°æµ‹è¯•

---

## ğŸ”§ è‡ªåŠ¨åŒ–æµ‹è¯•å·¥å…·

### GitHub Actionsé…ç½®

```yaml
# .github/workflows/automated-testing.yml
name: Automated Testing
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    - cron: '0 2 * * *'    # æ¯å¤©å‡Œæ™¨2ç‚¹
    - cron: '0 14 * * *'   # æ¯å¤©ä¸‹åˆ2ç‚¹

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - name: è¿è¡Œå•å…ƒæµ‹è¯•
        run: npm run test:unit
        timeout: 60000
      - name: ä¸Šä¼ è¦†ç›–ç‡æŠ¥å‘Š
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info

  integration-tests:
    needs: unit-tests
    runs-on: ubuntu-latest
    steps:
      - name: è¿è¡Œé›†æˆæµ‹è¯•
        run: npm run test:integration
        timeout: 120000

  e2e-tests:
    needs: integration-tests
    runs-on: ubuntu-latest
    steps:
      - name: å¯åŠ¨æµ‹è¯•ç¯å¢ƒ
        run: npm run test:e2e:setup
      - name: è¿è¡ŒE2Eæµ‹è¯•
        run: npm run test:e2e
        timeout: 300000
```

### æœ¬åœ°æµ‹è¯•å·¥å…·

```bash
# package.json scripts
{
  "scripts": {
    "test": "jest",
    "test:unit": "jest --testPath=tests/unit",
    "test:integration": "jest --testPath=tests/integration",
    "test:e2e": "playwright test",
    "test:e2e:setup": "playwright install && npx playwright test --config=playwright.config.ts",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:performance": "k6 run tests/performance/load-test.js",
    "test:security": "npm run test:security",
    "test:business-logic": "jest --testPath=tests/business-logic"
  }
}
```

---

**é‡è¦æé†’**ï¼š
1. æµ‹è¯•æ˜¯è´¨é‡ä¿è¯çš„æ ¸å¿ƒï¼Œå¿…é¡»ä¸¥æ ¼æ‰§è¡Œ
2. æµ‹è¯•è¦†ç›–ç‡æ˜¯è´¨é‡çš„é‡è¦æŒ‡æ ‡
3. è‡ªåŠ¨åŒ–æµ‹è¯•æé«˜æµ‹è¯•æ•ˆç‡å’Œå¯é æ€§
4. æŒç»­ç»´æŠ¤å’Œæ›´æ–°æµ‹è¯•ç”¨ä¾‹
5. æµ‹è¯•å¤±è´¥æ˜¯è´¨é‡é—®é¢˜çš„é¢„è­¦ä¿¡å·ï¼Œå¿…é¡»é‡è§†å¹¶è§£å†³