# 缓存系统使用指南

## 概述

中道商城系统已经完成了Redis缓存系统的实现，提供了高性能、可扩展的缓存解决方案。缓存系统自动在Redis和内存缓存之间切换，确保高可用性。

## 特性

### 🚀 核心特性
- **自动降级**: Redis不可用时自动切换到内存缓存
- **智能策略**: 支持多种缓存策略（LRU、TTL、标签失效）
- **高性能**: 支持批量操作、管道操作
- **监控告警**: 实时监控缓存性能，自动告警

### 📊 性能目标
- 缓存命中率 > 80%
- 数据库查询减少 70%
- API响应时间降低 50%
- 支持高并发读写

## 快速开始

### 1. 基础使用

```typescript
import { cacheManager } from '@/shared/cache/CacheManager';

// 设置缓存
await cacheManager.set('user:123', userData, { ttl: 600 });

// 获取缓存
const user = await cacheManager.get('user:123');

// 删除缓存
await cacheManager.del('user:123');
```

### 2. 使用Remember模式

```typescript
// 自动处理缓存逻辑
const result = await cacheManager.remember('expensive:operation', async () => {
  return await expensiveOperation();
}, { ttl: 300 });
```

### 3. 批量操作

```typescript
// 批量设置
await cacheManager.mset([
  { key: 'key1', value: data1 },
  { key: 'key2', value: data2 }
]);

// 批量获取
const results = await cacheManager.mget(['key1', 'key2']);
```

## 中间件使用

### 1. 基础缓存中间件

```typescript
import { cacheMiddleware } from '@/shared/middleware/cache';

// 自动缓存GET请求响应
router.get('/api/products',
  cacheMiddleware({
    ttl: 600, // 10分钟
    tags: ['products']
  }),
  async (req, res) => {
    const products = await getProducts();
    res.json(products);
  }
);
```

### 2. 专用缓存中间件

```typescript
import {
  userCacheMiddleware,
  productCacheMiddleware,
  teamCacheMiddleware,
  pointsCacheMiddleware
} from '@/shared/middleware/cache';

// 用户API缓存
router.get('/api/users/profile',
  userCacheMiddleware({ ttl: 300 }),
  getUserProfile
);

// 产品API缓存
router.get('/api/products/list',
  productCacheMiddleware({ ttl: 1800 }),
  getProductList
);
```

### 3. 缓存失效中间件

```typescript
import { invalidateCacheMiddleware, invalidateTagsMiddleware } from '@/shared/middleware/cache';

// 更新产品后清除相关缓存
router.put('/api/products/:id',
  invalidateTagsMiddleware(['products', 'product-list']),
  updateProduct
);

// 清除特定模式的缓存
router.post('/api/admin/cache/clear',
  invalidateCacheMiddleware(['user:*', 'product:*']),
  clearCache
);
```

## 高级功能

### 1. 标签管理

```typescript
// 设置带标签的缓存
await cacheManager.set('product:123', productData, {
  ttl: 1800,
  tags: ['product', 'featured', 'category:electronics']
});

// 通过标签失效
await cacheManager.invalidateTags(['featured']);
// 会清除所有带 'featured' 标签的缓存
```

### 2. 缓存策略

```typescript
import { Cached, CacheInvalidate } from '@/shared/cache/decorators';

class UserService {
  @Cached({ ttl: 600, tags: ['user-profile'] })
  async getUserProfile(userId: string) {
    return await database.findUser(userId);
  }

  @CacheInvalidate(['user-profile', 'user-stats'])
  async updateUserProfile(userId: string, data: any) {
    return await database.updateUser(userId, data);
  }
}
```

### 3. 原子操作

```typescript
// 原子递增
const newCount = await cacheManager.incr('counter:page:views');

// 原子递减
const newBalance = await cacheManager.decr('user:123:balance', amount);

// 使用锁防止并发
const lockAcquired = await cacheManager.setnx('lock:operation:123', '1', { ttl: 10 });
if (lockAcquired) {
  try {
    // 执行需要互斥的操作
  } finally {
    await cacheManager.del('lock:operation:123');
  }
}
```

## 缓存管理命令行工具

### 1. 查看缓存状态

```bash
# 查看整体状态
npm run cache:status

# 查看详细信息
npm run cache:status -- --details
```

### 2. 清理缓存

```bash
# 清理所有缓存
npm run cache:clear all

# 清理过期缓存
npm run cache:clear expired

# 清理特定模块缓存
npm run cache:clear user
npm run cache:clear product
```

### 3. 预热缓存

```bash
# 预热所有模块
npm run cache:warmup all

# 预热特定用户
npm run cache:warmup user -- --ids=user1,user2,user3

# 从文件读取ID列表预热
npm run cache:warmup product -- --file=product-ids.txt
```

### 4. 实时监控

```bash
# 启动实时监控（默认5秒刷新）
npm run cache:monitor

# 自定义刷新间隔
npm run cache:monitor -- --interval=3
```

### 5. 性能测试

```bash
# 运行1000次操作的性能测试
npm run cache:test -- --number=1000
```

## 业务模块缓存

### 1. 用户缓存

```typescript
import { UserCacheService } from '@/modules/users/cache';

const userCache = new UserCacheService();

// 缓存用户基本信息
await userCache.setUserProfile(userId, userData);
const profile = await userCache.getUserProfile(userId);

// 缓存用户等级进度
await userCache.setUserLevelProgress(userId, progressData);
const progress = await userCache.getUserLevelProgress(userId);

// 清除用户所有缓存
await userCache.invalidateAllUserData(userId);
```

### 2. 产品缓存

```typescript
import { ProductCacheService } from '@/modules/products/cache';

const productCache = new ProductCacheService();

// 缓存产品详情
await productCache.setProductDetail(productId, productData);
const product = await productCache.getProductDetail(productId);

// 缓存产品列表
await productCache.setProductList(params, productList);
const list = await productCache.getProductList(params);

// 缓存搜索结果
await productCache.setSearchResults(query, params, searchResults);
```

### 3. 团队缓存

```typescript
import { TeamCacheService } from '@/modules/team/cache';

const teamCache = new TeamCacheService();

// 缓存团队层级结构
await teamCache.setTeamHierarchy(userId, hierarchy);
const hierarchy = await teamCache.getTeamHierarchy(userId);

// 缓存团队统计
await teamCache.setTeamStats(userId, stats);
const stats = await teamCache.getTeamStats(userId);
```

### 4. 积分缓存

```typescript
import { PointsCacheService } from '@/modules/points/cache';

const pointsCache = new PointsCacheService();

// 缓存积分余额（短TTL）
await pointsCache.setBalance(userId, balanceData);
const balance = await pointsCache.getBalance(userId);

// 原子操作积分
const newBalance = await pointsCache.incrBalance(userId, amount);
const success = await pointsCache.acquireLock(userId, 'transfer', 10);
```

## 监控和统计

### 1. 健康检查端点

```typescript
// GET /api/v1/cache/health
{
  "status": "healthy",
  "score": 95,
  "uptime": 3600000,
  "issues": []
}
```

### 2. 统计概览端点

```typescript
// GET /api/v1/cache/stats/overview
{
  "global": {
    "hits": 10000,
    "misses": 2000,
    "hitRate": 83.33,
    "memory": { "used": 134217728 }
  },
  "modules": {
    "users": { "totalCached": 500 },
    "products": { "totalCached": 1000 }
  }
}
```

### 3. 性能指标端点

```typescript
// GET /api/v1/cache/metrics
{
  "summary": {
    "totalRequests": 12000,
    "hitRate": 83.33,
    "avgResponseTime": 45.5
  },
  "trends": {
    "hitRate": [...],
    "responseTime": [...]
  }
}
```

## 最佳实践

### 1. 缓存键设计

```typescript
// 推荐的键命名规范
user:{userId}:profile          // 用户资料
user:{userId}:level-progress    // 用户等级进度
product:{productId}:detail     // 产品详情
product:category:{catId}:page:{page}  // 分类产品列表
search:{query}:page:{page}     // 搜索结果
```

### 2. TTL设置建议

| 数据类型 | TTL | 说明 |
|---------|-----|------|
| 用户基本信息 | 10分钟 | 变动频率中等 |
| 产品详情 | 30分钟 | 变动频率较低 |
| 产品列表 | 5-15分钟 | 根据业务调整 |
| 搜索结果 | 5分钟 | 实时性要求高 |
| 积分余额 | 30秒 | 实时性要求极高 |
| 统计数据 | 5-60分钟 | 根据统计周期 |
| 配置信息 | 1-24小时 | 变动频率低 |

### 3. 标签使用策略

```typescript
// 按模块分类
['user', 'product', 'order', 'team', 'points']

// 按功能分类
['profile', 'list', 'detail', 'search', 'stats']

// 组合使用
['user:profile', 'product:detail', 'team:stats']
```

### 4. 缓存穿透防护

```typescript
// 使用空值缓存
const result = await cacheManager.get(key);
if (result === null) {
  // 检查是否为空值缓存
  const exists = await cacheManager.exists(key + ':empty');
  if (!exists) {
    // 实际查询
    const data = await database.query();
    if (data) {
      await cacheManager.set(key, data);
    } else {
      // 缓存空值，短TTL
      await cacheManager.set(key + ':empty', 'empty', { ttl: 60 });
    }
  }
}
```

### 5. 批量操作优化

```typescript
// 推荐：使用批量操作
const keys = user.map(id => `user:${id}:profile`);
const profiles = await cacheManager.mget(keys);

// 避免：循环单个操作
// for (const id of userIds) {
//   const profile = await cacheManager.get(`user:${id}:profile`);
// }
```

## 故障排查

### 1. Redis连接问题

```typescript
// 检查连接状态
const health = await cacheManager.healthCheck();
if (!health) {
  console.log('Redis不可用，已切换到内存缓存');
}

// 检查当前缓存类型
const config = cacheManager.getConfig();
console.log('当前使用:', config.currentType);
```

### 2. 缓存命中率低

```bash
# 查看缓存统计
npm run cache:status

# 检查监控告警
curl http://localhost:3000/api/v1/cache/alerts
```

### 3. 内存使用过高

```bash
# 查看内存使用
npm run cache:status -- --details

# 清理过期缓存
npm run cache:clear expired

# 清理特定模块
npm run cache:clear user
```

## 环境配置

### 1. Redis配置

```env
# .env.development
REDIS_URL=redis://localhost:6379
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0

# 生产环境建议使用集群
# REDIS_URL=redis://cluster-node1:6379,redis://cluster-node2:6379
```

### 2. 缓存配置

```typescript
// src/config/cache.ts
export const cacheConfig = {
  // 是否启用缓存
  enabled: process.env.CACHE_ENABLED !== 'false',

  // 默认TTL
  defaultTTL: parseInt(process.env.CACHE_DEFAULT_TTL || '300'),

  // 最大内存使用
  maxMemory: parseInt(process.env.CACHE_MAX_MEMORY || '1024') * 1024 * 1024,

  // 是否启用降级
  fallbackEnabled: process.env.CACHE_FALLBACK !== 'false',

  // 监控配置
  monitoring: {
    enabled: true,
    interval: 60000,
    thresholds: {
      hitRateMin: 70,
      memoryMax: 80,
      errorRateMax: 5
    }
  }
};
```

## 性能优化建议

### 1. 数据结构优化

- 使用JSON序列化复杂对象
- 避免缓存大对象（>1MB）
- 合理设置TTL
- 使用批量操作

### 2. 查询优化

- 先查缓存再查数据库
- 使用remember模式
- 批量获取数据
- 预热热点数据

### 3. 内存管理

- 定期清理过期缓存
- 监控内存使用
- 设置合理的缓存大小限制
- 使用LRU淘汰策略

## 常见问题

### Q: 如何处理缓存雪崩？
A: 使用随机TTL、熔断器、降级策略，避免大量缓存同时失效。

### Q: 如何处理缓存击穿？
A: 使用互斥锁、空值缓存，防止大量请求同时查询数据库。

### Q: 如何处理缓存穿透？
A: 缓存空结果、布隆过滤器、参数校验，避免无效请求。

### Q: 如何保证数据一致性？
A: 使用标签失效、版本控制、更新时主动清除缓存。

## 总结

缓存系统已经成功集成到中道商城系统中，提供了完整的缓存解决方案。通过合理使用缓存，可以显著提升系统性能，减少数据库压力。建议定期监控缓存效果，根据业务需求调整缓存策略。